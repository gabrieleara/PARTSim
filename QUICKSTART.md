# PARTSim Very Quick Start Guide

## Building

Fetch any updates from submodules using:
```bash
git submodule update --recursive --init
```

Run the project builder with multiple paralell threads (and release build
options):
```bash
./tools/builder.py -cJ build
```
and ta-da, you now have your executable in `build/rtsim/rtsim`.

> For a debug build supply `-b debug` to the builder. For embedding debug
> symbols in a release build use `-b release-wdebug`.

## Running

The easiest way to run PARTSim is to use one of the simulation configuration
files in [simconf]. A quick example is the following one:
```bash
./build/rtsim/rtsim \
  simconf/systems/odroid-xu3-partitioned-tb.yml\
  simconf/tasksets/odroid-xu3-dag.yml \
  10000 \
  --trace trace-out.txt
```
which will use the system definition for an ODROID-XU3 board, a taskset with a
DAG inside and will run the simulation for 10000 time units, saving a trace of
all task events in `trace-out.txt`. Arguments not starting with `-` or `--` are
positional **AND** required.

For more info on command-line options try running `./build/rtsim/rtsim --help`.

Configuration files provided with the simulator are structured like this:
 - [simconf/models] contains task model files;
 - [simconf/systems] contains system definition files;
 - [simconf/tasksets] contains tasksets definition files; tasksets which contain
   regular independent tasks or DAGs.

### Task Model Files

They are either specified in Balsini-Pannocchi model notation (see [this
example][bpmodel]) or in Table-Based notation, generated by our other tool,
PARTProf. You do not directly supply these files to the executable, but they are
referred by the system definition files (using their relative path with respect
tot he system definition files).

### System Definition Files

They are YAML files[^1] structured like the following example (all options are
mandatory):
```yml
cpu_islands:
  # CPU Island Specification
  - name: little
    # Number of CPUs
    numcpus: 4
    # Kernel specification
    kernel:
      # Supported schedulers: edf, rm (maybe), fifo (maybe)
      scheduler: edf
      # Task placement strategy: partitioned or global
      task_placement: partitioned
    # List of all voltages and frequencies (must be same-length)
    volts: [ 0.92, 0.919643, ... ]
    freqs: [200, 300, ... ]
    # Selected frequency to run (dynamic frequency switching not supported)
    base_freq: 200
    # Task Power and Speed models by name (both must be present)
    power_model: little
    speed_model: little
  - # Optional definition of other CPU islands ...
power_models:
  # Task Power/Speed Model Specification
  - name: little
    # Model type, either table_based or balsini_pannocchi
    type: table_based
    # Model file relative path
    filename: ../models/tb/odroid-xu3-maximum-fixed_regression.csv
  - # Optional definition of other models ...
```

### Taskset Definition Files

They are YAML files[^1] which contain two related specifications:
 - The tasks in the taskset to run on the system;
 - Task resouces, which are used for synchronization between tasks.

#### Tasks

Each task is characterized by:

 - `name`: an identifying name

 - `iat`: task inter-arrival time (=period);

 - `rdl`: relative deadline (optional, defaults to the value in `iat`); same
   limitations to `runtime` apply.

 - `ph`: initial phasing for task inter-arrival (default=0);

 - `qs`: queue size (default: 100);

 - `runtime`: the runtime to set for the task reservation (all tasks are
   encapsulated in CBS Servers, no exceptions); must be >= 1 (if you use 0 the
   task will always miss and never run, even if it has only instructions with 0
   duration like `lock` and `unlock`).

 - `startcpu`: specifies the CPU on which the task is released. For
   `partitioned` task placing, this is also the only CPU on which the task will
   ever execute. For `global` task placing, the task will be able to migrate to
   any CPU, without any distinction about CPU islands and core types.

 - `code`: list of instructions to execute.

Following is a list of accepted instructions:

- `fixed(n, workload_type)`: takes an integer number and a string, generates an
  instruction with fixed computation time of the given workload type. Task
  execution time is scaled according to the `speed` of the CPU on which it is
  running, selected according to the `base_freq` attribute in the System
  Definition File depending on the model used and the supplied workload type.

- `wait(r)` or `lock(r)`: takes a string r containing the name of a resource and
  produces a WaitInstr on that resource;

- `signal(r)` or `unlock(r)`: takes a string r containing the name of a resource
  and produces a SignalInstr on that resource;

- `activate(t)`: takes a string containing the name of a task and generates an
  ActivateInstr on that task (**NOTE: UNTESTED**).

#### Resources

Each resource has a `name` and an `initial-state` (either `locked` or
`unlocked`). Multi-instance resources do work in the simulator, but there is no
support to create one from a YML file yet.

For DAGs, all resources (except the one that blocks the first task to run) must
start locked and the first task to run will release the other tasks. A DAG
cannot start if its previous execution did not terminate completely.

> A simple convention (used also in the example below) for DAG dependencies is
> to specify which tasks are involved: for example, `c_task_i_j` represents the
> fact that task `j` cannot start if task `i` did not terminate yet. Special
> value `X` for a task (instead of a number) indicates a virtual task (either
> `dag_begin` or `dag_end`). However, this is just a convention and you must
> specify these precedences by emitting the right instructions in each task
> body.

#### Example

Following is an example of the file structure:
```yml
# Specifies all the tasks
taskset:
  # First task to run in the DAG
  - name: dag_begin
    iat: 1000
    runtime: 1
    rdl: 1
    startcpu: 4
    code:
      # Locks on DAG to ensure that previous instance terminated
      - lock(DAG)
      # Releases all tasks with no precedence constraints
      - unlock(c_task_X_0)

  - name: task_0
    iat: 1000
    runtime: 1000
    startcpu: 4
    code:
      # Locks on all its precedence constraints (if no real constraints,
      # must lock against the dag_begin task)
      - lock(c_task_X_0)
      - fixed(200,gzip-1)
      # Unlocks all its successors (or dag_end if no real successor)
      - unlock(c_task_0_1)
      - unlock(c_task_0_2)

  - name: task_2
    iat: 1000
    runtime: 1000
    startcpu: 2
    code:
      - lock(c_task_0_2)
      - fixed(200,gzip-1)
      - unlock(c_task_2_X)

  - name: task_1
    startcpu: 3
    iat: 1000
    runtime: 1000
    code:
      - lock(c_task_0_1)
      - fixed(500,gzip-1)
      - unlock(c_task_1_X)

  # Last task to run in the DAG
  - name: dag_end
    iat: 1000
    runtime: 1
    startcpu: 1
    code:
      # Locks on all DAG tasks that have no successor
      - lock(c_task_1_X)
      - lock(c_task_2_X)
      # Unlocks dag_begin (hopefully before the next activation)
      - unlock(DAG)
# Specifies all "resources" used for synchronization
resources:
  # List each resource here
  - name: DAG
    initial-state: unlocked
  - name: c_task_X_0
    initial-state: locked
  - name: c_task_0_1
    initial-state: locked
  - name: c_task_0_2
    initial-state: locked
  - name: c_task_1_X
    initial-state: locked
  - name: c_task_2_X
    initial-state: locked
```


----
<!-- Footnotes -->

[^1]: Not all features of the YAML format are supported. In particular,
    JSON-style declarations are not supported.

<!-- Links -->

[simconf]: simconf
[simconf/systems]: simconf/systems
[simconf/models]: simconf/models
[simconf/tasksets]: simconf/tasksets
[bpmodel]: simconf/models/bp/odroid-xu3.csv
